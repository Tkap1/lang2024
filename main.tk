
#include "raylib.tk"
#include "data.tk"
#include "constants.tk"
#include "globals.tk"

func int main()
{
	game_state.curr = 1;
	editor.state.curr = 1;
	SetTraceLogLevel(LOG_WARNING);
	SetConfigFlags(FLAG_VSYNC_HINT);

	InitWindow(ww, wh, "AZEN");
	SetExitKey(0);

	g_textures[e_texture.player_body] = load_texture("assets/pink_body_square.png");
	g_textures[e_texture.tile] = load_texture("assets/tile_grey.png");
	g_textures[e_texture.player_face] = load_texture("assets/face_h.png");
	g_textures[e_texture.player_hand] = load_texture("assets/pink_hand_open.png");
	g_textures[e_texture.explosion1] = load_texture("assets/explosion-d1.png");
	g_textures[e_texture.explosion2] = load_texture("assets/explosion-d2.png");
	g_textures[e_texture.explosion3] = load_texture("assets/explosion-d3.png");
	g_textures[e_texture.explosion4] = load_texture("assets/explosion-d4.png");
	g_textures[e_texture.explosion5] = load_texture("assets/explosion-d5.png");
	g_textures[e_texture.explosion6] = load_texture("assets/explosion-d6.png");
	g_textures[e_texture.explosion7] = load_texture("assets/explosion-d7.png");
	g_textures[e_texture.explosion8] = load_texture("assets/explosion-d8.png");
	g_textures[e_texture.explosion9] = load_texture("assets/explosion-d9.png");
	g_textures[e_texture.explosion10] = load_texture("assets/explosion-d10.png");
	g_textures[e_texture.explosion11] = load_texture("assets/explosion-d11.png");
	g_textures[e_texture.explosion12] = load_texture("assets/explosion-d12.png");
	g_textures[e_texture.projectile] = load_texture("assets/blue_body_circle.png");

	g_animations[e_animation.explosion].delay = 0.025;
	g_animations[e_animation.explosion].frame_count = 12;
	g_animations[e_animation.explosion].frames[0] = e_texture.explosion1;
	g_animations[e_animation.explosion].frames[1] = e_texture.explosion2;
	g_animations[e_animation.explosion].frames[2] = e_texture.explosion3;
	g_animations[e_animation.explosion].frames[3] = e_texture.explosion4;
	g_animations[e_animation.explosion].frames[4] = e_texture.explosion5;
	g_animations[e_animation.explosion].frames[5] = e_texture.explosion6;
	g_animations[e_animation.explosion].frames[6] = e_texture.explosion7;
	g_animations[e_animation.explosion].frames[7] = e_texture.explosion8;
	g_animations[e_animation.explosion].frames[8] = e_texture.explosion9;
	g_animations[e_animation.explosion].frames[9] = e_texture.explosion10;
	g_animations[e_animation.explosion].frames[10] = e_texture.explosion11;
	g_animations[e_animation.explosion].frames[11] = e_texture.explosion12;

	tile_size = v2(g_textures[e_texture.tile].width * 0.25, g_textures[e_texture.tile].height * 0.25);
	player_size = v2(g_textures[e_texture.player_body].width * 0.4, g_textures[e_texture.player_body].height * 0.4);
	projectile_size = v2(16, 16);
	spike_size = tile_size;

	camera.zoom = 1;
	camera.offset.x = ww / 2 - player_size.x / 2;
	camera.offset.y = wh / 2 - player_size.y / 2;

	game.player.pos = v2(32, 32);

	int bottom_tile = wh / tile_size.x;
	for x: c_max_tiles {
		g_map.tiles[bottom_tile][x] = 1;
	}

	while !WindowShouldClose() {
		delta = GetFrameTime();

		do_input();
		update_timer += delta;
		while update_timer >= c_update_delay {
			update_timer -= c_update_delay;
			update();
		}
		s_map* map =  &g_map;
		if(game_state.curr == e_state.editor) {
			map = &editor.map;
		}
		render(map);
	}
}

func void do_input()
{
	import input;

	int is_ctrl_down = IsKeyDown(KEY_LEFT_CONTROL);
	left_click_down = IsMouseButtonDown(MOUSE_BUTTON_LEFT);
	left_click_pressed = IsMouseButtonPressed(MOUSE_BUTTON_LEFT);
	left_click_released = IsMouseButtonReleased(MOUSE_BUTTON_LEFT);
	confirm = IsKeyPressed(KEY_ENTER);

	wheel = GetMouseWheelMove();

	// @Note(tkap, 18/02/2024): Game
	if game_state.curr == e_state.game {
		if IsKeyPressed(KEY_F1) {
			set_next_state(&game_state, 2);
		}

		shoot = IsMouseButtonDown(MOUSE_BUTTON_LEFT);
		move_left = IsKeyDown(KEY_LEFT) || IsKeyDown(KEY_A);
		move_right = IsKeyDown(KEY_RIGHT) || IsKeyDown(KEY_D);
		jump = IsKeyPressed(KEY_SPACE);
	}

	// @Note(tkap, 18/02/2024): Editor
	if game_state.curr == e_state.editor {
		if IsKeyPressed(KEY_F1) {
			set_next_state(&game_state, 1);
		}
		int can_move = editor.state.curr != e_editor_state.save && editor.state.curr != e_editor_state.load && !is_ctrl_down;

		move_tile_left = pressed_or_repeat(KEY_LEFT);
		move_tile_right = pressed_or_repeat(KEY_RIGHT);
		move_tile_up = pressed_or_repeat(KEY_UP);
		move_tile_down = pressed_or_repeat(KEY_DOWN);
		move_left = IsKeyDown(KEY_A) && can_move;
		move_right = IsKeyDown(KEY_D) && can_move;
		move_up = IsKeyDown(KEY_W) && can_move;
		move_down = IsKeyDown(KEY_S) && can_move;
		place_tile = IsMouseButtonDown(MOUSE_BUTTON_LEFT);

		for 10 {
			numbers[it] = IsKeyPressed(KEY_ZERO + it);
		}

		cancel = IsKeyPressed(KEY_ESCAPE);
		remove_tiles = IsKeyPressed(KEY_DELETE);
		delete_char = pressed_or_repeat(KEY_BACKSPACE);

		if is_ctrl_down && IsKeyPressed(KEY_Z) {
			undo = 1;
		}
		if is_ctrl_down && IsKeyPressed(KEY_S) {
			save_map = 1;
		}
		if is_ctrl_down && IsKeyPressed(KEY_L) {
			load_map = 1;
		}

	}
}

func void update()
{
	mouse = GetMousePosition();
	world_mouse = to_world(mouse, camera);

	if input.wheel < 0 {
		camera.zoom = max(0.1, camera.zoom * 0.9);
	}
	if input.wheel > 0 {
		camera.zoom = min(5, camera.zoom * 1.1);
	}
	input.wheel = 0;

	if game.player.shoot_timer < c_shoot_delay {
		game.player.shoot_timer += 1;
	}

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		change state start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if game_state.next != 0 {
		game_state.curr = game_state.next;
		if game_state.next == e_state.game {
			g_map = editor.map;
		}
		if game_state.next == e_state.editor {
			editor.map = g_map;
		}
		game_state.next = 0;
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		change state end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		gameplay start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if game_state.curr == e_state.game {

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		create projectiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		if game.player.shoot_timer >= c_shoot_delay && input.shoot {
			game.player.shoot_timer -= c_shoot_delay;
			for c_max_projectiles {
				import game.projectiles;
				if !active[it] {
					active[it] = 1;
					pos[it] = game.player.pos;
					vel[it] = dir_from_to(pos[it], world_mouse);
					vel[it].x *= c_projectile_speed;
					vel[it].y *= c_projectile_speed;
					break;
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		create projectiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		{
			s_v2 dir;
			if input.move_left {
				dir.x -= 1;
			}
			if input.move_right {
				dir.x += 1;
			}
			if !game.player.on_ground {
				dir.x *= 0.1;
			}
			if dir.x > 0 && game.player.vel.x < c_max_walk_vel {
				game.player.vel.x = min(c_max_walk_vel, game.player.vel.x + dir.x);
			}
			if dir.x < 0 && game.player.vel.x > -c_max_walk_vel {
				game.player.vel.x = max(-c_max_walk_vel, game.player.vel.x + dir.x);
			}
		}

		game.player.vel.y += c_gravity;

		if game.player.on_ground && consume_input(&input.jump) {
			game.player.vel.y = -3;
		}

		game.player.x += game.player.vel.x;

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		x collision start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		{
			s_v2i player_index = v2i(floorf(game.player.x / tile_size.x), floorf(game.player.y / tile_size.y));
			for y: 7 {
				int yy = -3 + y;
				for x: 7 {
					int xx = -3 + x;
					s_v2i index = v2i(player_index.x + xx, player_index.y + yy);
					if index.x < 0 || index.x >= c_max_tiles { continue; }
					if index.y < 0 || index.y >= c_max_tiles { continue; }

					s8 tile = g_map.tiles[index.y][index.x];
					s_v2 tile_pos = v2(index.x * tile_size.x, index.y * tile_size.y);
					if tile > 0 {
						if rect_collides_rect(get_topleft(game.player.pos, player_size), player_size, tile_pos, tile_size) {
							if game.player.vel.x > 0 {
								game.player.x = tile_pos.x - player_size.x / 2;
							}
							else {
								game.player.x = tile_pos.x + tile_size.x + player_size.x / 2;
							}
							game.player.vel.x = 0;
						}
					}
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		x collision end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		game.player.y += game.player.vel.y;

		int is_grounded = 0;

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		y collision start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		{
			s_v2i player_index = v2i(floorf(game.player.x / tile_size.x), floorf(game.player.y / tile_size.y));
			for y: 7 {
				int yy = -3 + y;
				for x: 7 {
					int xx = -3 + x;
					s_v2i index = v2i(player_index.x + xx, player_index.y + yy);
					if index.x < 0 || index.x >= c_max_tiles { continue; }
					if index.y < 0 || index.y >= c_max_tiles { continue; }

					s8 tile = g_map.tiles[index.y][index.x];
					s_v2 tile_pos = v2(index.x * tile_size.x, index.y * tile_size.y);
					if tile > 0 {
						if rect_collides_rect(get_topleft(game.player.pos, player_size), player_size, tile_pos, tile_size) {
							if game.player.vel.y > 0 {
								game.player.y = tile_pos.y - player_size.y / 2;
								is_grounded = 1;
							}
							else {
								game.player.y = tile_pos.y + tile_size.y + player_size.y / 2;
							}
							game.player.vel.y = 0;
						}
					}
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		y collision end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		if game.player.on_ground {
			game.player.vel.x *= 0.8;
		}
		game.player.on_ground = is_grounded;

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		projectiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		for c_max_projectiles {
			import game.projectiles;

			if !active[it] { continue; }
			pos[it].x += vel[it].x;
			pos[it].y += vel[it].y;

			s_v2i col = get_tile_collision(pos[it], projectile_size);
			if col.x == -1 { continue; }
			active[it] = 0;
			float distance = v2_distance(pos[it], game.player.pos);
			float strength = smoothstep(128, 32, distance) * 5;
			s_v2 dir = dir_from_to(pos[it], game.player.pos);
			s_v2 push = dir * strength;
			game.player.vel.x += push.x;
			game.player.vel.y += push.y;
			s_animation anim;
			anim.id = e_animation.explosion;
			anim.pos = pos[it];
			animations[animation_count] = anim;
			animation_count += 1;
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		projectiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		camera.pos.x = game.player.x;
		camera.pos.y = game.player.y;

	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		gameplay end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	if game_state.curr == e_state.editor {
		update_editor();
	}

}

func void render(s_map* map)
{
	BeginDrawing();
	ClearBackground(BLACK);

	float time = GetTime();

	mouse = GetMousePosition();
	world_mouse = to_world(mouse, camera);

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		render tiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	{
		s_rect bounds = get_camera_bounds(camera);
		int left = bounds.x / tile_size.x - 1;
		int right = bounds.size.x / tile_size.x + 1;
		int top = bounds.y / tile_size.y - 1;
		int bottom = bounds.size.y / tile_size.y + 1;
		for y: (bottom - top) {
			int yy = top + y;
			if yy < 0 { continue; }
			if yy >= c_max_tiles { continue; }
			for x: (right - left) {
				int xx = left + x;
				if xx < 0 { continue; }
				if xx >= c_max_tiles { continue; }
				s8 tile = map.tiles[yy][xx];
				s_v2 tile_pos = v2(xx * tile_size.x, yy * tile_size.y);
				s_color color = DARK;
				if tile == 0 {
					if xx % 2 == 0 {
						color = {100, 25, 25, 255};
					}
				}
				if tile == 1 {
					color = WHITE;
				}
				draw_texture(g_textures[e_texture.tile], tile_pos, tile_size, color, 0, &camera);
				if tile > 0 && game_state.curr == e_state.editor && editor.tiles_selected[yy][xx] {
					float size = sin2(time * 10) * tile_size.x;
					s_color temp_color = GREEN;
					temp_color.a = 150;
					draw_texture(g_textures[e_texture.tile], get_center(tile_pos, tile_size), v2(size, size), temp_color, 1, &camera);
				}
			}
		}
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		render tiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		player render start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	{
		import game.player;
		draw_texture(g_textures[e_texture.player_body], pos, player_size, WHITE, 1, &camera);

		{
			s_v2 face_pos = pos;
			draw_texture_scaled(g_textures[e_texture.player_face], face_pos, 0.5, WHITE, 1, &camera);
		}

		{
			s_v2 hand_pos = pos;
			hand_pos.x -= player_size.x * 0.9;
			hand_pos.y += sinf(time * 6) * 5;
			draw_texture_scaled(g_textures[e_texture.player_hand], hand_pos, 0.5, WHITE, 1, &camera);
		}

		{
			s_v2 hand_pos = pos;
			hand_pos.x += player_size.x * 0.9;
			hand_pos.y += sinf(time * 6) * 5;
			draw_texture_scaled(g_textures[e_texture.player_hand], hand_pos, 0.5, WHITE, 1, &camera);
		}
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		player render end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		projectiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	for c_max_projectiles {
		import game.projectiles;
		if !active[it] { continue; }
		draw_texture(g_textures[e_texture.projectile], pos[it], projectile_size, WHITE, 1, &camera);
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		projectiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		spikes render start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	for c_max_spikes {
		import map.spikes;
		if !active[it] { continue; }
		s_v2 draw_pos = tile_index_to_pos(pos[it]);
		draw_texture(g_textures[e_texture.projectile], draw_pos, spike_size, RED, 0, &camera);
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		spikes render end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	for animation_count {
		s_animation* anim = &animations[it];
		s_animation_data data = g_animations[anim.id];
		draw_texture(g_textures[data.frames[anim.curr_frame]], anim.pos, player_size * 2, WHITE, 1, &camera);
		anim.time += delta;
		if anim.time > data.delay {
			anim.time -= data.delay;
			anim.curr_frame = (anim.curr_frame + 1) % data.frame_count;
			if anim.curr_frame == 0 {
				animation_count -= 1;
				animations[it] = animations[animation_count];
				continue;
			}
		}
	}

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		render editor start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if game_state.curr == e_state.editor {
		if editor.state.curr == e_editor_state.select {
			draw_text("select", v2(400, 100));

			if editor.selecting {
				s_rect rect = get_editor_selection_rectangle();
				rect.pos = to_screen(rect.pos, camera);
				rect.size *= camera.zoom;
				DrawRectangleLines(rect.pos.x, rect.pos.y, rect.size.x, rect.size.y, WHITE);
			}
		}

		if editor.state.curr == e_editor_state.paint {
			draw_text("paint", v2(400, 100));
		}

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		editor save render start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		if editor.state.curr == e_editor_state.save {
			draw_text("save", v2(400, 100));
			if(editor.save_load_input[0]) {
				draw_text(editor.save_load_input, v2(400, 500));
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		editor save render end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		editor load render start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		if editor.state.curr == e_editor_state.load {
			draw_text("load", v2(400, 100));
			if(editor.save_load_input[0]) {
				draw_text(editor.save_load_input, v2(400, 500));
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		editor load render end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		render editor end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	DrawFPS(16, 16);

	EndDrawing();
}

func s_v2i get_tile_collision(s_v2 pos, s_v2 size)
{
	s_v2i base_index = v2i(floorf(pos.x / tile_size.x), floorf(pos.y / tile_size.y));
	for y: 7 {
		int yy = -3 + y;
		for x: 7 {
			int xx = -3 + x;
			s_v2i index = v2i(base_index.x + xx, base_index.y + yy);
			if index.x < 0 || index.x >= c_max_tiles { continue; }
			if index.y < 0 || index.y >= c_max_tiles { continue; }

			s8 tile = g_map.tiles[index.y][index.x];
			s_v2 tile_pos = v2(index.x * tile_size.x, index.y * tile_size.y);
			if tile > 0 {
				if rect_collides_rect(pos, size, tile_pos, tile_size) {
					return index;
				}
			}
		}
	}
	return v2i(-1, -1);
}

func float smoothstep(float edge0, float edge1, float val)
{
	float t = clamp((val - edge0) / (edge1 - edge0), 0.0, 1.0);
	return t * t * (3.0 - 2.0 * t);
}

func float v2_distance(s_v2 a, s_v2 b)
{
	a.x -= b.x;
	a.y -= b.y;
	return v2_length(a);
}

func float clamp(float val, float min_val, float max_val)
{
	return max(min(val, max_val), min_val);
}

func float min(float a, float b)
{
	if a >= b { return b; }
	return a;
}

func float max(float a, float b)
{
	if a <= b { return b; }
	return a;
}

func s_v2 to_screen(s_v2 v, s_camera cam)
{
	s_v2 result = v;
	result -= cam.pos;
	result *= cam.zoom;
	result += cam.offset;
	return result;
}

func s_v2 to_world(s_v2 v, s_camera cam)
{
	s_v2 result = v;
	result -= cam.offset;
	result /= cam.zoom;
	result += cam.pos;
	return result;
}

func s_rect get_camera_bounds(s_camera cam)
{
	import cam;
	s_rect result;
	result.pos = to_world(v2(0, 0), cam);
	result.size = to_world(v2(ww, wh), cam);
	return result;
}

func s_v2 v2(float x, float y)
{
	return {x, y};
}

func s_v2i v2i(int x, int y)
{
	return {x, y};
}

func b8 rect_collides_rect(s_v2 pos1, s_v2 size1, s_v2 pos2, s_v2 size2)
{
	return pos1.x + size1.x > pos2.x && pos1.x < pos2.x + size2.x &&
		pos1.y + size1.y > pos2.y && pos1.y < pos2.y + size2.y;
}

func s_v2 get_center(s_v2 pos, s_v2 size)
{
	s_v2 result = pos;
	result.x += size.x / 2;
	result.y += size.y / 2;
	return result;
}

func float v2_length(s_v2 v)
{
	return sqrtf(v.x * v.x + v.y * v.y);
}

func s_v2 v2_normalized(s_v2 v)
{
	float length = v2_length(v);
	if(length > 0) {
		v.x /= length;
		v.y /= length;
	}
	return v;
}

func s_v2 dir_from_to(s_v2 from, s_v2 to)
{
	s_v2 result = to;
	result.x -= from.x;
	result.y -= from.y;
	return v2_normalized(result);
}

func s_v2i pos_to_tile_index(s_v2 pos)
{
	return v2i(pos.x / tile_size.x, pos.y / tile_size.y);
}

func int is_valid_tile_index(s_v2i index) {
	if index.x < 0 || index.x >= c_max_tiles { return 0; }
	if index.y < 0 || index.y >= c_max_tiles { return 0; }
	return 1;
}

func s_texture load_texture(char* path)
{
	s_texture texture = LoadTexture(path);
	SetTextureFilter(texture, TEXTURE_FILTER_ANISOTROPIC_16X);
	return texture;
}

func void draw_texture(s_texture texture, s_v2 pos, s_v2 size, s_color color, int centered, s_camera* cam)
{
	if cam {
		pos = to_screen(pos, *cam);
		size *= cam.zoom;
	}
	s_rect dst;
	dst.pos = pos;
	dst.size = size;
	s_rect src;
	src.size.x = texture.width;
	src.size.y = texture.height;
	s_v2 origin = v2(0, 0);
	if centered {
		origin.x = size.x / 2;
		origin.y = size.y / 2;
	}
	DrawTexturePro(texture, src, dst, origin, 0, color);
}

func void draw_texture_scaled(s_texture texture, s_v2 pos, float scale, s_color color, int centered, s_camera* cam)
{
	if cam {
		pos = to_screen(pos, *cam);
		scale *= cam.zoom;
	}
	s_rect src;
	src.size.x = texture.width;
	src.size.y = texture.height;
	s_rect dst;
	dst.pos = pos;
	dst.size.x = texture.width * scale;
	dst.size.y = texture.height * scale;
	s_v2 origin = v2(0, 0);
	if centered {
		origin.x = dst.size.x / 2;
		origin.y = dst.size.y / 2;
	}
	DrawTexturePro(texture, src, dst, origin, 0, color);
}

func s_v2 get_topleft(s_v2 pos, s_v2 size)
{
	pos.x -= size.x / 2;
	pos.y -= size.y / 2;
	return pos;
}

func s_v2 operator*(s_v2 a, float b)
{
	a.x *= b;
	a.y *= b;
	return a;
}

func s_v2 operator/(s_v2 a, float b)
{
	a.x /= b;
	a.y /= b;
	return a;
}

func s_v2 operator+(s_v2 a, s_v2 b)
{
	a.x += b.x;
	a.y += b.y;
	return a;
}

func s_v2 operator-(s_v2 a, s_v2 b)
{
	a.x -= b.x;
	a.y -= b.y;
	return a;
}

func void set_next_state(s_state* state, int next)
{
	state.next = next;
}

func void draw_text(char* text, s_v2 pos)
{
	DrawText(text, pos.x, pos.y, 32, WHITE);
}

func int consume_input(int* i)
{
	int result = 0;
	if *i > 0 {
		*i = 0;
		result = 1;
	}
	return result;
}

func s_rect rect_from_points(s_v2 a, s_v2 b)
{
	s_rect rect;
	rect.pos = a;
	rect.size.x = b.x - a.x;
	rect.size.y = b.y - a.y;
	return rect;
}

func s_rect get_editor_selection_rectangle()
{
	s_v2 min_bounds = v2(
		min(editor.selection_start.x, world_mouse.x),
		min(editor.selection_start.y, world_mouse.y)
	);
	s_v2 max_bounds = v2(
		max(editor.selection_start.x, world_mouse.x),
		max(editor.selection_start.y, world_mouse.y)
	);
	return rect_from_points(min_bounds, max_bounds);
}

func float sin2(float t)
{
	return sinf(t) * 0.5 + 0.5;
}

func void editor_save_undo()
{
	editor.undo_stack[editor.undo_index] = editor.data;
	editor.undo_index = (editor.undo_index + 1) % c_editor_max_undo;
	editor.undo_count = min(editor.undo_count + 1, c_editor_max_undo);
}

func void editor_undo()
{
	if editor.undo_count <= 0 { return; }
	editor.undo_index -= 1;
	if editor.undo_index < 0 {
		editor.undo_index = c_editor_max_undo - 1;
	}
	editor.data = editor.undo_stack[editor.undo_index];
	editor.undo_count -= 1;
}

func void do_save_map(char* name, s_map* map)
{
	FILE_* file = fopen(name, "wb");
	int version = c_map_version;
	fwrite(&version, 1, sizeof(int), file);
	fwrite(map, 1, sizeof(s_map), file);
	fclose(file);
}

func void do_load_map(char* name, s_map* out_map)
{
	FILE_* file = fopen(name, "rb");
	int version;
	fread(&version, 1, sizeof(int), file);
	fread(out_map, 1, sizeof(s_map), file);
	fclose(file);
}

func void update_editor()
{
	import editor;
	if consume_input(&input.save_map) {
		set_next_state(&state, e_editor_state.save);
	}

	if consume_input(&input.load_map) {
		set_next_state(&state, e_editor_state.load);
	}

	s_v2 dir;
	if input.move_left {
		dir.x -= 1;
	}
	if input.move_right {
		dir.x += 1;
	}
	if input.move_up {
		dir.y -= 1;
	}
	if input.move_down {
		dir.y += 1;
	}
	camera.pos += v2_normalized(dir) * cam_speed;

	if state.next > 0 {
		state.curr = state.next;
		if state.next == e_editor_state.paint {
			memset(tiles_selected, 0, sizeof(tiles_selected));
		}
		if state.next == e_editor_state.save {
			save_load_cursor = 0;
			save_load_input[0] = 0;
		}
		if state.next == e_editor_state.load {
			save_load_cursor = 0;
			save_load_input[0] = 0;
		}
		state.next = 0;
	}

	if consume_input(&input.undo) {
		editor_undo();
	}


	if state.curr == e_editor_state.select {
		if consume_input(&input.numbers[1]) {
			curr_tile = 1;
			set_next_state(&state, 2);
		}
		if consume_input(&input.numbers[2]) {
			curr_tile = 2;
			set_next_state(&state, 2);
		}
		if consume_input(&input.left_click_pressed) {
			selecting = 1;
			selection_start = world_mouse;
		}

		if selecting && consume_input(&input.left_click_released) {
			selecting = 0;
			memset(tiles_selected, 0, sizeof(tiles_selected));
			s_rect rect = get_editor_selection_rectangle();
			for y: c_max_tiles {
				for x: c_max_tiles {
					if map.tiles[y][x] <= 0 { continue; }
					s_v2 tile_pos = v2(x * tile_size.x, y * tile_size.y);
					if rect_collides_rect(rect.pos, rect.size, tile_pos, tile_size) {
						tiles_selected[y][x] = 1;
					}
				}
			}
		}

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		move tiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		{
			int[4] move;
			s_v2i[4] offsets;
			move[0] = consume_input(&input.move_tile_up);
			move[1] = consume_input(&input.move_tile_left);
			move[2] = consume_input(&input.move_tile_right);
			move[3] = consume_input(&input.move_tile_down);
			offsets[0] = v2i(0, -1);
			offsets[1] = v2i(-1, 0);
			offsets[2] = v2i(1, 0);
			offsets[3] = v2i(0, 1);
			for offset: offsets {
				if !move[offset_index] { continue; }
				int first_move = 1;
				s8[c_max_tiles][c_max_tiles] new_tiles;
				memset(new_tiles, 0, sizeof(new_tiles));
				int[c_max_tiles][c_max_tiles] new_tiles_selected;
				memset(new_tiles_selected, 0, sizeof(new_tiles_selected));

				for y: c_max_tiles {
					for x: c_max_tiles {
						if !tiles_selected[y][x] {
							new_tiles[y][x] = map.tiles[y][x];
						}
					}
				}

				int hit_a_border = 0;
				for y: c_max_tiles {
					for x: c_max_tiles {
						if !tiles_selected[y][x] { continue; }
						s_v2i index = v2i(x + offset.x, y + offset.y);
						if !is_valid_tile_index(index) { hit_a_border = 1; }
						if !hit_a_border {
							if first_move {
								first_move = 0;
								editor_save_undo();
							}
							new_tiles[index.y][index.x] = map.tiles[y][x];
							new_tiles_selected[index.y][index.x] = tiles_selected[y][x];
						}
						else {
							new_tiles[y][x] = map.tiles[y][x];
							new_tiles_selected[y][x] = tiles_selected[y][x];
						}
					}
				}
				map.tiles = new_tiles;
				tiles_selected = new_tiles_selected;
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		move tiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		if consume_input(&input.remove_tiles) {
			int deleted_something = 0;
			for y: c_max_tiles {
				for x: c_max_tiles {
					if tiles_selected[y][x] {
						if !deleted_something {
							editor_save_undo();
							deleted_something = 1;
						}
						map.tiles[y][x] = 0;
						tiles_selected[y][x] = 0;
					}
				}
			}
			memset(tiles_selected, 0, sizeof(tiles_selected));
		}
	}

	if state.curr == e_editor_state.paint {
		if consume_input(&input.cancel) {
			set_next_state(&state, 1);
		}

		if consume_input(&input.numbers[1]) {
			curr_tile = 1;
			set_next_state(&state, 2);
		}
		if consume_input(&input.numbers[2]) {
			curr_tile = 2;
			set_next_state(&state, 2);
		}

		if painting && consume_input(&input.left_click_released) {
			painting = 0;
		}

		if input.place_tile {
			s_v2i index = pos_to_tile_index(world_mouse);
			if is_valid_tile_index(index) {
				if curr_tile == 1 {
					if map.tiles[index.y][index.x] != 1 && !painting {
						painting = 1;
						editor_save_undo();
					}
					map.tiles[index.y][index.x] = 1;
				}
				if curr_tile == 2 {
					int spike = get_spike_at_index(index, &map);
					if spike < 0 {
						if !painting {
							painting = 1;
							editor_save_undo();
						}
						spike = add_spike(index, &map);
					}
				}
			}
		}
	}

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		editor save update start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if state.curr == e_editor_state.save {
		if consume_input(&input.cancel) {
			set_next_state(&state, e_editor_state.select);
		}
		while 1 {
			int c = GetCharPressed();
			if !c { break; }
			save_load_input[save_load_cursor] = c;
			save_load_input[save_load_cursor + 1] = 0;
			save_load_cursor += 1;
		}
		if consume_input(&input.delete_char) {
			if save_load_cursor > 0 {
				save_load_cursor -= 1;
				save_load_input[save_load_cursor] = 0;
			}
		}
		if save_load_input[0] && consume_input(&input.confirm) {
			do_save_map(save_load_input, &map);
			set_next_state(&state, e_editor_state.select);
		}
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		editor save update end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		editor load update start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if state.curr == e_editor_state.load {
		if consume_input(&input.cancel) {
			set_next_state(&state, e_editor_state.select);
		}
		while 1 {
			int c = GetCharPressed();
			if !c { break; }
			save_load_input[save_load_cursor] = c;
			save_load_input[save_load_cursor + 1] = 0;
			save_load_cursor += 1;
		}
		if consume_input(&input.delete_char) {
			if save_load_cursor > 0 {
				save_load_cursor -= 1;
				save_load_input[save_load_cursor] = 0;
			}
		}
		if save_load_input[0] && consume_input(&input.confirm) {
			do_load_map(save_load_input, &map);
			set_next_state(&state, e_editor_state.select);
		}
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		editor load update end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
}

func b32 pressed_or_repeat(int key)
{
	return IsKeyPressed(key) || IsKeyPressedRepeat(key);
}

func int get_spike_at_index(s_v2i index, s_map* map)
{
	import map.spikes;
	for c_max_spikes {
		if !active[it] { continue; }
		if v2i_equals(pos[it], index) { return it; }
	}
	return -1;
}

func b32 v2i_equals(s_v2i a, s_v2i b)
{
	return a.x == b.x && a.y == b.y;
}

func int add_spike(s_v2i in_pos, s_map* map)
{
	import map.spikes;
	for c_max_spikes {
		if active[it] { continue; }
		active[it] = 1;
		pos[it] = in_pos;
		return it;
	}
	return -1;
}

func s_v2 tile_index_to_pos(s_v2i index)
{
	return v2(index.x * tile_size.x, index.y * tile_size.y);
}