

// raylib

struct s_color
{
	u8 r,
	u8 g,
	u8 b,
	u8 a,
}
struct s_texture
{
	u32 id,
	int width,
	int height,
	int mipmaps,
	int format,
}

const int LOG_WARNING = 4;
const int FLAG_VSYNC_HINT = 64;
const s_color BLACK = {0, 0, 0, 0};
const s_color RED = {230, 41, 55, 255};
const s_color GREEN = {0, 228, 48, 255};
const s_color BLUE = {0, 121, 241, 255};
const s_color WHITE = {255, 255, 255, 255};
const s_color DARK = {50, 50, 50, 255};
const int MOUSE_BUTTON_LEFT = 0;
const int MOUSE_BUTTON_RIGHT = 1;

const int KEY_NULL = 0;
const int KEY_APOSTROPHE = 39;
const int KEY_COMMA = 44;
const int KEY_MINUS = 45;
const int KEY_PERIOD = 46;
const int KEY_SLASH = 47;
const int KEY_ZERO = 48;
const int KEY_ONE = 49;
const int KEY_TWO = 50;
const int KEY_THREE = 51;
const int KEY_FOUR = 52;
const int KEY_FIVE = 53;
const int KEY_SIX = 54;
const int KEY_SEVEN = 55;
const int KEY_EIGHT = 56;
const int KEY_NINE = 57;
const int KEY_SEMICOLON = 59;
const int KEY_EQUAL = 61;
const int KEY_A = 65;
const int KEY_B = 66;
const int KEY_C = 67;
const int KEY_D = 68;
const int KEY_E = 69;
const int KEY_F = 70;
const int KEY_G = 71;
const int KEY_H = 72;
const int KEY_I = 73;
const int KEY_J = 74;
const int KEY_K = 75;
const int KEY_L = 76;
const int KEY_M = 77;
const int KEY_N = 78;
const int KEY_O = 79;
const int KEY_P = 80;
const int KEY_Q = 81;
const int KEY_R = 82;
const int KEY_S = 83;
const int KEY_T = 84;
const int KEY_U = 85;
const int KEY_V = 86;
const int KEY_W = 87;
const int KEY_X = 88;
const int KEY_Y = 89;
const int KEY_Z = 90;
const int KEY_LEFT_BRACKET = 91;
const int KEY_BACKSLASH = 92;
const int KEY_RIGHT_BRACKET = 93;
const int KEY_GRAVE = 96;
const int KEY_SPACE = 32;
const int KEY_ESCAPE = 256;
const int KEY_ENTER = 257;
const int KEY_TAB = 258;
const int KEY_BACKSPACE = 259;
const int KEY_INSERT = 260;
const int KEY_DELETE = 261;
const int KEY_RIGHT = 262;
const int KEY_LEFT = 263;
const int KEY_DOWN = 264;
const int KEY_UP = 265;
const int KEY_PAGE_UP = 266;
const int KEY_PAGE_DOWN = 267;
const int KEY_HOME = 268;
const int KEY_END = 269;
const int KEY_CAPS_LOCK = 280;
const int KEY_SCROLL_LOCK = 281;
const int KEY_NUM_LOCK = 282;
const int KEY_PRINT_SCREEN = 283;
const int KEY_PAUSE = 284;
const int KEY_F1 = 290;
const int KEY_F2 = 291;
const int KEY_F3 = 292;
const int KEY_F4 = 293;
const int KEY_F5 = 294;
const int KEY_F6 = 295;
const int KEY_F7 = 296;
const int KEY_F8 = 297;
const int KEY_F9 = 298;
const int KEY_F10 = 299;
const int KEY_F11 = 300;
const int KEY_F12 = 301;
const int KEY_LEFT_SHIFT = 340;
const int KEY_LEFT_CONTROL = 341;
const int KEY_LEFT_ALT = 342;
const int KEY_LEFT_SUPER = 343;
const int KEY_RIGHT_SHIFT = 344;
const int KEY_RIGHT_CONTROL = 345;
const int KEY_RIGHT_ALT = 346;
const int KEY_RIGHT_SUPER = 347;
const int KEY_KB_MENU = 348;
const int KEY_KP_0 = 320;
const int KEY_KP_1 = 321;
const int KEY_KP_2 = 322;
const int KEY_KP_3 = 323;
const int KEY_KP_4 = 324;
const int KEY_KP_5 = 325;
const int KEY_KP_6 = 326;
const int KEY_KP_7 = 327;
const int KEY_KP_8 = 328;
const int KEY_KP_9 = 329;
const int KEY_KP_DECIMAL = 330;
const int KEY_KP_DIVIDE = 331;
const int KEY_KP_MULTIPLY = 332;
const int KEY_KP_SUBTRACT = 333;
const int KEY_KP_ADD = 334;
const int KEY_KP_ENTER = 335;
const int KEY_KP_EQUAL = 336;
const int KEY_BACK = 4;
const int KEY_MENU = 5;
const int KEY_VOLUME_UP = 24;
const int KEY_VOLUME_DOWN = 2;
const int TEXTURE_FILTER_ANISOTROPIC_16X = 5;

struct s_v2
{
	float x,
	float y,
}

struct s_v2i
{
	int x,
	int y,
}

struct s_rect
{
	import s_v2 pos,
	s_v2 size,
}


external_func void SetTraceLogLevel(s32);
external_func void SetConfigFlags(u32);
external_func void InitWindow(s32, s32, char*);
external_func b32 WindowShouldClose();
external_func void BeginDrawing();
external_func void DrawRectangle(s32, s32, s32, s32, s_color);
external_func void DrawFPS(s32, s32);
external_func void EndDrawing();
external_func void ClearBackground(s_color);
external_func int rand();
external_func s_v2 GetMousePosition();
external_func b32 IsMouseButtonPressed(int);
external_func b32 IsMouseButtonReleased(int);
external_func b32 IsMouseButtonDown(int);
external_func float floorf(float);
external_func b32 IsKeyDown(int);
external_func b32 IsKeyPressed(int);
external_func s_texture LoadTexture(char*);
external_func void SetTextureFilter(s_texture, int);
external_func float sinf(float);
external_func float sqrtf(float);
external_func double GetTime();
external_func float GetFrameTime();
external_func int printf(char*);
external_func void SetTargetFPS(int);
external_func void DrawTexturePro(s_texture, s_rect, s_rect, s_v2, float, s_color);
external_func void SetExitKey(int);
external_func void DrawText(char*, int, int, int, s_color);
external_func void DrawRectangleLines(int, int, int, int, s_color);
external_func void* memset(void*, int, size_t);

enum e_editor_state
{
	invalid,
	select,
	paint,
}

struct s_player
{
	import s_v2 pos,
	s_v2 vel,
	int shoot_timer,
}

struct s_input_data
{
	int shoot,
	int move_left,
	int move_right,
	int move_up,
	int move_down,
	int move_tile_left,
	int move_tile_right,
	int move_tile_up,
	int move_tile_down,
	int jump,
	int place_tile,
	int one,
	int cancel,
	int left_click_down,
	int left_click_pressed,
	int left_click_released,
	int remove_tiles,
	int undo,
}

const int c_max_projectiles = 128;

struct s_projectiles
{
	b8[c_max_projectiles] active,
	s_v2[c_max_projectiles] pos,
	s_v2[c_max_projectiles] vel,
}

struct s_camera
{
	s_v2 pos,
	s_v2 offset,
}

const int c_max_tiles = 64;

enum e_animation
{
	explosion,
}

enum e_texture
{
	player_face,
	player_body,
	player_hand,
	tile,
	explosion1,
	explosion2,
	explosion3,
	explosion4,
	explosion5,
	explosion6,
	explosion7,
	explosion8,
	explosion9,
	explosion10,
	explosion11,
	explosion12,
	projectile,
}

struct s_state
{
	int curr,
	int next,
}

const int c_editor_max_undo = 16;

// @Note(tkap, 15/02/2024): For things that get undone/redone by undo system
struct s_editor_data
{
	s8[c_max_tiles][c_max_tiles] tiles,
	int[c_max_tiles][c_max_tiles] tiles_selected,
}

struct s_editor
{
	import s_editor_data data,
	int painting,
	int undo_count,
	int undo_index,
	s_editor_data[c_editor_max_undo] undo_stack,
	s_v2 selection_start,
	int selecting,
	s_state state,
	int curr_tile,
}

struct s_animation
{
	s_v2 pos,
	int id,
	float time,
	int curr_frame,
}

struct s_animation_data
{
	float delay,
	int frame_count,
	int[32] frames,
}

s_texture[e_texture.count] g_textures;
s_animation_data[e_animation.count] g_animations;
s8[c_max_tiles][c_max_tiles] g_tiles;
s_camera camera;
float delta;
float update_timer;
const int c_updates_per_second = 240;
const float c_update_delay = 1.0 / c_updates_per_second;
const int ww = 1280;
const int wh = 900;
s_v2 tile_size;
s_v2 player_size;
s_player player;
s_projectiles projectiles;
s_v2 projectile_size;
s_v2 mouse;
s_v2 world_mouse;
const int c_shoot_delay = 20;
const float c_max_walk_vel = 1;
s_state game_state;
s_input_data input;
s_editor editor;
int animation_count = 0;
s_animation[128] animations;

func int main()
{

	game_state.curr = 1;
	editor.state.curr = 1;
	SetTraceLogLevel(LOG_WARNING);
	SetConfigFlags(FLAG_VSYNC_HINT);

	InitWindow(ww, wh, "AZEN");
	SetExitKey(0);

	g_textures[e_texture.player_body] = load_texture("assets/pink_body_square.png");
	g_textures[e_texture.tile] = load_texture("assets/tile_grey.png");
	g_textures[e_texture.player_face] = load_texture("assets/face_h.png");
	g_textures[e_texture.player_hand] = load_texture("assets/pink_hand_open.png");
	g_textures[e_texture.explosion1] = load_texture("assets/explosion-d1.png");
	g_textures[e_texture.explosion2] = load_texture("assets/explosion-d2.png");
	g_textures[e_texture.explosion3] = load_texture("assets/explosion-d3.png");
	g_textures[e_texture.explosion4] = load_texture("assets/explosion-d4.png");
	g_textures[e_texture.explosion5] = load_texture("assets/explosion-d5.png");
	g_textures[e_texture.explosion6] = load_texture("assets/explosion-d6.png");
	g_textures[e_texture.explosion7] = load_texture("assets/explosion-d7.png");
	g_textures[e_texture.explosion8] = load_texture("assets/explosion-d8.png");
	g_textures[e_texture.explosion9] = load_texture("assets/explosion-d9.png");
	g_textures[e_texture.explosion10] = load_texture("assets/explosion-d10.png");
	g_textures[e_texture.explosion11] = load_texture("assets/explosion-d11.png");
	g_textures[e_texture.explosion12] = load_texture("assets/explosion-d12.png");
	g_textures[e_texture.projectile] = load_texture("assets/blue_body_circle.png");

	g_animations[e_animation.explosion].delay = 0.025;
	g_animations[e_animation.explosion].frame_count = 12;
	g_animations[e_animation.explosion].frames[0] = e_texture.explosion1;
	g_animations[e_animation.explosion].frames[1] = e_texture.explosion2;
	g_animations[e_animation.explosion].frames[2] = e_texture.explosion3;
	g_animations[e_animation.explosion].frames[3] = e_texture.explosion4;
	g_animations[e_animation.explosion].frames[4] = e_texture.explosion5;
	g_animations[e_animation.explosion].frames[5] = e_texture.explosion6;
	g_animations[e_animation.explosion].frames[6] = e_texture.explosion7;
	g_animations[e_animation.explosion].frames[7] = e_texture.explosion8;
	g_animations[e_animation.explosion].frames[8] = e_texture.explosion9;
	g_animations[e_animation.explosion].frames[9] = e_texture.explosion10;
	g_animations[e_animation.explosion].frames[10] = e_texture.explosion11;
	g_animations[e_animation.explosion].frames[11] = e_texture.explosion12;

	// for e_texture.count {
	// 	printf("%i\n", g_textures[it].width);
	// }

	tile_size = v2(g_textures[e_texture.tile].width * 0.25, g_textures[e_texture.tile].height * 0.25);
	player_size = v2(g_textures[e_texture.player_body].width * 0.4, g_textures[e_texture.player_body].height * 0.4);
	projectile_size = v2(16, 16);

	player.pos = v2(32, 32);

	int bottom_tile = wh / tile_size.x;
	for x: c_max_tiles {
		g_tiles[bottom_tile][x] = 1;
	}


	while !WindowShouldClose() {
		delta = GetFrameTime();

		do_input();
		update_timer += delta;
		while update_timer >= c_update_delay {
			update_timer -= c_update_delay;
			update();
		}
		s8[c_max_tiles][c_max_tiles]* tiles = &g_tiles;
		if(game_state.curr == 2) {
			tiles = &editor.tiles;
		}
		render(tiles);
	}
}

func void do_input()
{

	input.left_click_down = IsMouseButtonDown(MOUSE_BUTTON_LEFT);
	input.left_click_pressed = IsMouseButtonPressed(MOUSE_BUTTON_LEFT);
	input.left_click_released = IsMouseButtonReleased(MOUSE_BUTTON_LEFT);

	// @Note(tkap, 18/02/2024): Game
	if game_state.curr == 1 {
		if IsKeyPressed(KEY_F1) {
			set_next_state(&game_state, 2);
		}

		input.shoot = IsMouseButtonDown(MOUSE_BUTTON_LEFT);
		input.move_left = IsKeyDown(KEY_LEFT) || IsKeyDown(KEY_A);
		input.move_right = IsKeyDown(KEY_RIGHT) || IsKeyDown(KEY_D);
		input.jump = IsKeyPressed(KEY_SPACE);
	}

	// @Note(tkap, 18/02/2024): Editor
	if game_state.curr == 2 {
		if IsKeyPressed(KEY_F1) {
			set_next_state(&game_state, 1);
		}

		input.move_tile_left = IsKeyPressed(KEY_LEFT);
		input.move_tile_right = IsKeyPressed(KEY_RIGHT);
		input.move_tile_up = IsKeyPressed(KEY_UP);
		input.move_tile_down = IsKeyPressed(KEY_DOWN);
		input.move_left = IsKeyDown(KEY_A);
		input.move_right = IsKeyDown(KEY_D);
		input.move_up = IsKeyDown(KEY_W);
		input.move_down = IsKeyDown(KEY_S);
		input.place_tile = IsMouseButtonDown(MOUSE_BUTTON_LEFT);
		input.one = IsKeyPressed(KEY_ONE);
		input.cancel = IsKeyPressed(KEY_ESCAPE);
		input.remove_tiles = IsKeyPressed(KEY_DELETE);

		if IsKeyDown(KEY_LEFT_CONTROL) && IsKeyPressed(KEY_Z) {
			input.undo = 1;
		}
	}
}

func void update()
{
	mouse = GetMousePosition();
	world_mouse = to_world(mouse);

	if player.shoot_timer < c_shoot_delay {
		player.shoot_timer += 1;
	}

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		change state start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if game_state.next != 0 {
		game_state.curr = game_state.next;
		if game_state.next == 1 {
			g_tiles = editor.tiles;
		}
		if game_state.next == 2 {
			editor.tiles = g_tiles;
		}
		game_state.next = 0;
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		change state end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		gameplay start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if game_state.curr == 1 {

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		create projectiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		if player.shoot_timer >= c_shoot_delay && input.shoot {
			player.shoot_timer -= c_shoot_delay;
			for c_max_projectiles {
				if !projectiles.active[it] {
					projectiles.active[it] = 1;
					projectiles.pos[it] = player.pos;
					projectiles.vel[it] = dir_from_to(projectiles.pos[it], world_mouse);
					projectiles.vel[it].x *= 10;
					projectiles.vel[it].y *= 10;
					break;
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		create projectiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		{
			s_v2 dir;
			if input.move_left {
				dir.x -= 1;
			}
			if input.move_right {
				dir.x += 1;
			}
			if dir.x > 0 && player.vel.x < c_max_walk_vel {
				player.vel.x = min(c_max_walk_vel, player.vel.x + dir.x);
			}
			if dir.x < 0 && player.vel.x > -c_max_walk_vel {
				player.vel.x = max(-c_max_walk_vel, player.vel.x + dir.x);
			}
		}

		player.vel.y += 0.09;

		if input.jump {
			input.jump = 0;
			player.vel.y = -3;
		}

		player.x += player.vel.x;

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		x collision start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		{
			s_v2i player_index = v2i(floorf(player.x / tile_size.x), floorf(player.y / tile_size.y));
			for y: 7 {
				int yy = -3 + y;
				for x: 7 {
					int xx = -3 + x;
					s_v2i index = v2i(player_index.x + xx, player_index.y + yy);
					if index.x < 0 || index.x >= c_max_tiles { continue; }
					if index.y < 0 || index.y >= c_max_tiles { continue; }

					s8 tile = g_tiles[index.y][index.x];
					s_v2 tile_pos = v2(index.x * tile_size.x, index.y * tile_size.x);
					if tile > 0 {
						if rect_collides_rect(get_topleft(player.pos, player_size), player_size, tile_pos, tile_size) {
							if player.vel.x > 0 {
								player.x = tile_pos.x - player_size.x / 2;
							}
							else {
								player.x = tile_pos.x + tile_size.x + player_size.x / 2;
							}
						}
					}
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		x collision end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		player.y += player.vel.y;

		int is_grounded = 0;

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		y collision start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		{
			s_v2i player_index = v2i(floorf(player.x / tile_size.x), floorf(player.y / tile_size.y));
			for y: 7 {
				int yy = -3 + y;
				for x: 7 {
					int xx = -3 + x;
					s_v2i index = v2i(player_index.x + xx, player_index.y + yy);
					if index.x < 0 || index.x >= c_max_tiles { continue; }
					if index.y < 0 || index.y >= c_max_tiles { continue; }

					s8 tile = g_tiles[index.y][index.x];
					s_v2 tile_pos = v2(index.x * tile_size.x, index.y * tile_size.x);
					if tile > 0 {
						if rect_collides_rect(get_topleft(player.pos, player_size), player_size, tile_pos, tile_size) {
							if player.vel.y > 0 {
								player.y = tile_pos.y - player_size.y / 2;
								is_grounded = 1;
							}
							else {
								player.y = tile_pos.y + tile_size.y + player_size.y / 2;
							}
							player.vel.y = 0;
						}
					}
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		y collision end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		if is_grounded {
			player.vel.x *= 0.8;
		}


		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		projectiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		for c_max_projectiles {
			if !projectiles.active[it] { continue; }
			projectiles.pos[it].x += projectiles.vel[it].x;
			projectiles.pos[it].y += projectiles.vel[it].y;

			s_v2 pos = projectiles.pos[it];
			s_v2i col = get_tile_collision(pos, projectile_size);
			if col.x == -1 { continue; }
			projectiles.active[it] = 0;
			float distance = v2_distance(pos, player.pos);
			float strength = smoothstep(128, 32, distance) * 5;
			s_v2 dir = dir_from_to(pos, player.pos);
			s_v2 push = dir * strength;
			player.vel.x += push.x;
			player.vel.y += push.y;
			s_animation anim;
			anim.id = e_animation.explosion;
			anim.pos = pos;
			animations[animation_count] = anim;
			animation_count += 1;
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		projectiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


		camera.offset.x = ww / 2 - player_size.x / 2;
		camera.offset.y = wh / 2 - player_size.y / 2;
		camera.pos.x = player.x;
		camera.pos.y = player.y;

	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		gameplay end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		editor start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if game_state.curr == 2 {

		camera.offset.x = ww / 2 - player_size.x / 2;
		camera.offset.y = wh / 2 - player_size.y / 2;
		const float cam_speed = 3;
		if input.move_left {
			camera.pos.x -= cam_speed;
		}
		if input.move_right {
			camera.pos.x += cam_speed;
		}
		if input.move_up {
			camera.pos.y -= cam_speed;
		}
		if input.move_down {
			camera.pos.y += cam_speed;
		}

		if editor.state.next > 0 {
			editor.state.curr = editor.state.next;
			if editor.state.next == e_editor_state.paint {
				memset(editor.tiles_selected, 0, c_max_tiles * c_max_tiles * 4);
			}
			editor.state.next = 0;
		}

		if consume_input(&input.undo) {
			editor_undo();
		}

		if editor.state.curr == e_editor_state.select {
			if consume_input(&input.one) {
				set_next_state(&editor.state, 2);
			}
			if consume_input(&input.left_click_pressed) {
				editor.selecting = 1;
				editor.selection_start = world_mouse;
			}

			if editor.selecting && consume_input(&input.left_click_released) {
				editor.selecting = 0;
				memset(editor.tiles_selected, 0, c_max_tiles * c_max_tiles * 4);
				s_rect rect = get_editor_selection_rectangle();
				for y: c_max_tiles {
					for x: c_max_tiles {
						if editor.tiles[y][x] <= 0 { continue; }
						s_v2 tile_pos = v2(x * tile_size.x, y * tile_size.y);
						if rect_collides_rect(rect.pos, rect.size, tile_pos, tile_size) {
							editor.tiles_selected[y][x] = 1;
						}
					}
				}
			}

			// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		move tiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
			{
				int[4] move;
				s_v2i[4] offsets;
				move[0] = consume_input(&input.move_tile_up);
				move[1] = consume_input(&input.move_tile_left);
				move[2] = consume_input(&input.move_tile_right);
				move[3] = consume_input(&input.move_tile_down);
				offsets[0] = v2i(0, -1);
				offsets[1] = v2i(-1, 0);
				offsets[2] = v2i(1, 0);
				offsets[3] = v2i(0, 1);
				for offset: offsets {
					if !move[offset_index] { continue; }
					int first_move = 1;
					s8[c_max_tiles][c_max_tiles] new_tiles;
					memset(new_tiles, 0, c_max_tiles * c_max_tiles);
					int[c_max_tiles][c_max_tiles] new_tiles_selected;
					memset(new_tiles_selected, 0, c_max_tiles * c_max_tiles * 4);

					for y: c_max_tiles {
						for x: c_max_tiles {
							if !editor.tiles_selected[y][x] {
								new_tiles[y][x] = editor.tiles[y][x];
							}
						}
					}

					int hit_a_border = 0;
					for y: c_max_tiles {
						for x: c_max_tiles {
							if !editor.tiles_selected[y][x] { continue; }
							s_v2i index = v2i(x + offset.x, y + offset.y);
							if !is_valid_tile_index(index) { hit_a_border = 1; }
							if !hit_a_border {
								if first_move {
									first_move = 0;
									editor_save_undo();
								}
								new_tiles[index.y][index.x] = editor.tiles[y][x];
								new_tiles_selected[index.y][index.x] = editor.tiles_selected[y][x];
							}
							else {
								new_tiles[y][x] = editor.tiles[y][x];
								new_tiles_selected[y][x] = editor.tiles_selected[y][x];
							}
						}
					}
					editor.tiles = new_tiles;
					editor.tiles_selected = new_tiles_selected;
				}
			}
			// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		move tiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

			if consume_input(&input.remove_tiles) {
				int deleted_something = 0;
				for y: c_max_tiles {
					for x: c_max_tiles {
						if editor.tiles_selected[y][x] {
							if !deleted_something {
								editor_save_undo();
								deleted_something = 1;
							}
							editor.tiles[y][x] = 0;
							editor.tiles_selected[y][x] = 0;
						}
					}
				}
				memset(editor.tiles_selected, 0, c_max_tiles * c_max_tiles * 4);
			}
		}

		if editor.state.curr == e_editor_state.paint {
			if consume_input(&input.cancel) {
				set_next_state(&editor.state, 1);
			}

			if editor.painting && consume_input(&input.left_click_released) {
				editor.painting = 0;
			}

			if input.place_tile {
				s_v2i index = pos_to_tile_index(world_mouse);
				if is_valid_tile_index(index) {
					if editor.tiles[index.y][index.x] != 1 && !editor.painting {
						editor.painting = 1;
						editor_save_undo();
					}
					editor.tiles[index.y][index.x] = 1;
				}
			}
		}
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		editor end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

}

func void render(s8[c_max_tiles][c_max_tiles]* tiles)
{
	BeginDrawing();
	ClearBackground(BLACK);

	float time = GetTime();

	mouse = GetMousePosition();
	world_mouse = to_world(mouse);

	{
		int right = (ww + camera.pos.x) / tile_size.x + 1;
		int down = (wh + camera.pos.y) / tile_size.y + 1;
		for y: down {
			if y >= c_max_tiles { continue; }
			for x: right {
				if x >= c_max_tiles { continue; }
				s8 tile = tiles[y][x];
				s_v2 tile_pos = v2(x * tile_size.x, y * tile_size.x);
				s_color color = DARK;
				if tile == 0 {
					if x % 2 == 0 {
						color = {100, 25, 25, 255};
					}
				}
				if tile == 1 {
					color = WHITE;
				}
				draw_texture(g_textures[e_texture.tile], to_screen(tile_pos), tile_size, color, 0);
				if tile > 0 && game_state.curr == 2 && editor.tiles_selected[y][x] {
					float size = sin2(time * 10) * tile_size.x;
					s_color temp_color = GREEN;
					temp_color.a = 150;
					draw_texture(g_textures[e_texture.tile], to_screen(get_center(tile_pos, tile_size)), v2(size, size), temp_color, 1);
				}
			}
		}
	}

	for animation_count {
		s_animation* anim = &animations[it];
		s_animation_data data = g_animations[anim.id];
		draw_texture(g_textures[data.frames[anim.curr_frame]], to_screen(anim.pos), player_size * 2, WHITE, 1);
		anim.time += delta;
		if anim.time > data.delay {
			anim.time -= data.delay;
			anim.curr_frame = (anim.curr_frame + 1) % data.frame_count;
			if anim.curr_frame == 0 {
				animation_count -= 1;
				animations[it] = animations[animation_count];
				continue;
			}
		}
	}


	draw_texture(g_textures[e_texture.player_body], to_screen(player.pos), player_size, WHITE, 1);

	{
		s_v2 face_pos = player.pos;
		draw_texture_scaled(g_textures[e_texture.player_face], to_screen(face_pos), 0.5, WHITE, 1);
	}

	{
		s_v2 hand_pos = player.pos;
		hand_pos.x -= player_size.x * 0.9;
		hand_pos.y += sinf(time * 6) * 5;
		draw_texture_scaled(g_textures[e_texture.player_hand], to_screen(hand_pos), 0.5, WHITE, 1);
	}

	{
		s_v2 hand_pos = player.pos;
		hand_pos.x += player_size.x * 0.9;
		hand_pos.y += sinf(time * 6) * 5;
		draw_texture_scaled(g_textures[e_texture.player_hand], to_screen(hand_pos), 0.5, WHITE, 1);
	}

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		projectiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	for c_max_projectiles {
		if !projectiles.active[it] { continue; }
		s_v2 pos = to_screen(projectiles.pos[it]);
		draw_texture(g_textures[e_texture.projectile], pos, projectile_size, WHITE, 1);
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		projectiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		editor start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if game_state.curr == 2 {
		if editor.state.curr == e_editor_state.select {
			draw_text("select", v2(400, 100));

			if editor.selecting {
				s_rect rect = get_editor_selection_rectangle();
				rect.pos = to_screen(rect.pos);
				DrawRectangleLines(rect.pos.x, rect.pos.y, rect.size.x, rect.size.y, WHITE);
			}
		}

		if editor.state.curr == e_editor_state.paint {
			draw_text("paint", v2(400, 100));
		}
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		editor end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	DrawFPS(16, 16);

	EndDrawing();
}

func s_v2i get_tile_collision(s_v2 pos, s_v2 size)
{
	s_v2i base_index = v2i(floorf(pos.x / tile_size.x), floorf(pos.y / tile_size.y));
	for y: 7 {
		int yy = -3 + y;
		for x: 7 {
			int xx = -3 + x;
			s_v2i index = v2i(base_index.x + xx, base_index.y + yy);
			if index.x < 0 || index.x >= c_max_tiles { continue; }
			if index.y < 0 || index.y >= c_max_tiles { continue; }

			s8 tile = g_tiles[index.y][index.x];
			s_v2 tile_pos = v2(index.x * tile_size.x, index.y * tile_size.x);
			if tile > 0 {
				if rect_collides_rect(pos, size, tile_pos, tile_size) {
					return index;
				}
			}
		}
	}
	return v2i(-1, -1);
}

func float smoothstep(float edge0, float edge1, float val)
{
	float t = clamp((val - edge0) / (edge1 - edge0), 0.0, 1.0);
	return t * t * (3.0 - 2.0 * t);
}

func float v2_distance(s_v2 a, s_v2 b)
{
	a.x -= b.x;
	a.y -= b.y;
	return v2_length(a);
}

func float clamp(float val, float min_val, float max_val)
{
	return max(min(val, max_val), min_val);
}

func float min(float a, float b)
{
	if a >= b { return b; }
	return a;
}

func float max(float a, float b)
{
	if a <= b { return b; }
	return a;
}

func s_v2 to_screen(s_v2 v)
{
	s_v2 result = v;
	result.x -= camera.pos.x;
	result.y -= camera.pos.y;
	result.x += camera.offset.x;
	result.y += camera.offset.y;
	return result;
}

func s_v2 to_world(s_v2 v)
{
	s_v2 result = v;
	result.x -= camera.offset.x;
	result.y -= camera.offset.y;
	result.x += camera.pos.x;
	result.y += camera.pos.y;
	return result;
}

func s_v2 v2(float x, float y)
{
	return {x, y};
}

func s_v2i v2i(int x, int y)
{
	return {x, y};
}

func b8 rect_collides_rect(s_v2 pos1, s_v2 size1, s_v2 pos2, s_v2 size2)
{
	return pos1.x + size1.x > pos2.x && pos1.x < pos2.x + size2.x &&
		pos1.y + size1.y > pos2.y && pos1.y < pos2.y + size2.y;
}

func s_v2 get_center(s_v2 pos, s_v2 size)
{
	s_v2 result = pos;
	result.x += size.x / 2;
	result.y += size.y / 2;
	return result;
}

func float v2_length(s_v2 v)
{
	return sqrtf(v.x * v.x + v.y * v.y);
}

func s_v2 v2_normalized(s_v2 v)
{
	float length = v2_length(v);
	if(length > 0) {
		v.x /= length;
		v.y /= length;
	}
	return v;
}

func s_v2 dir_from_to(s_v2 from, s_v2 to)
{
	s_v2 result = to;
	result.x -= from.x;
	result.y -= from.y;
	return v2_normalized(result);
}

func s_v2i pos_to_tile_index(s_v2 pos)
{
	return v2i(pos.x / tile_size.x, pos.y / tile_size.y);
}

func int is_valid_tile_index(s_v2i index) {
	if index.x < 0 || index.x >= c_max_tiles { return 0; }
	if index.y < 0 || index.y >= c_max_tiles { return 0; }
	return 1;
}

func s_texture load_texture(char* path)
{
	s_texture texture = LoadTexture(path);
	SetTextureFilter(texture, TEXTURE_FILTER_ANISOTROPIC_16X);
	return texture;
}

func void draw_texture(s_texture texture, s_v2 pos, s_v2 size, s_color color, int centered)
{
	s_rect dst;
	dst.pos = pos;
	dst.size = size;
	s_rect src;
	src.size.x = texture.width;
	src.size.y = texture.height;
	s_v2 origin = v2(0, 0);
	if centered {
		origin.x = size.x / 2;
		origin.y = size.y / 2;
	}
	DrawTexturePro(texture, src, dst, origin, 0, color);
}

func void draw_texture_scaled(s_texture texture, s_v2 pos, float scale, s_color color, int centered)
{
	s_rect src;
	src.size.x = texture.width;
	src.size.y = texture.height;
	s_rect dst;
	dst.pos = pos;
	dst.size.x = texture.width * scale;
	dst.size.y = texture.height * scale;
	s_v2 origin = v2(0, 0);
	if centered {
		origin.x = dst.size.x / 2;
		origin.y = dst.size.y / 2;
	}
	DrawTexturePro(texture, src, dst, origin, 0, color);
}

func s_v2 get_topleft(s_v2 pos, s_v2 size)
{
	pos.x -= size.x / 2;
	pos.y -= size.y / 2;
	return pos;
}

func s_v2 operator*(s_v2 a, float b)
{
	a.x *= b;
	a.y *= b;
	return a;
}

func void set_next_state(s_state* state, int next)
{
	state.next = next;
}

func void draw_text(char* text, s_v2 pos)
{
	DrawText(text, pos.x, pos.y, 32, WHITE);
}

func int consume_input(int* i)
{
	int result = 0;
	if *i > 0 {
		*i = 0;
		result = 1;
	}
	return result;
}

func s_rect rect_from_points(s_v2 a, s_v2 b)
{
	s_rect rect;
	rect.pos = a;
	rect.size.x = b.x - a.x;
	rect.size.y = b.y - a.y;
	return rect;
}

func s_rect get_editor_selection_rectangle()
{
	s_v2 min_bounds = v2(
		min(editor.selection_start.x, world_mouse.x),
		min(editor.selection_start.y, world_mouse.y)
	);
	s_v2 max_bounds = v2(
		max(editor.selection_start.x, world_mouse.x),
		max(editor.selection_start.y, world_mouse.y)
	);
	return rect_from_points(min_bounds, max_bounds);
}

func float sin2(float t)
{
	return sinf(t) * 0.5 + 0.5;
}

func void editor_save_undo()
{
	editor.undo_stack[editor.undo_index] = editor.data;
	editor.undo_index = (editor.undo_index + 1) % c_editor_max_undo;
	editor.undo_count = min(editor.undo_count + 1, c_editor_max_undo);
}

func void editor_undo()
{
	if editor.undo_count <= 0 { return; }
	editor.undo_index -= 1;
	if editor.undo_index < 0 {
		editor.undo_index = c_editor_max_undo - 1;
	}
	editor.data = editor.undo_stack[editor.undo_index];
	editor.undo_count -= 1;
}