

// raylib

struct s_color
{
	u8 r,
	u8 g,
	u8 b,
	u8 a,
}
const int LOG_WARNING = 4;
const int FLAG_VSYNC_HINT = 64;
const s_color BLACK = {0, 0, 0, 0};
const s_color RED = {230, 41, 55, 255};
const s_color GREEN = {0, 228, 48, 255};
const s_color BLUE = {0, 121, 241, 255};
const int MOUSE_BUTTON_LEFT = 0;
const int MOUSE_BUTTON_RIGHT = 1;


struct s_v2
{
	float x,
	float y,
}


struct s_v2i
{
	int x,
	int y,
}


external_func void SetTraceLogLevel(s32);
external_func void SetConfigFlags(u32);
external_func void InitWindow(s32, s32, char*);
external_func b32 WindowShouldClose();
external_func void BeginDrawing();
external_func void DrawRectangle(s32, s32, s32, s32, s_color);
external_func void DrawFPS(s32, s32);
external_func void EndDrawing();
external_func void ClearBackground(s_color);
external_func int rand();
external_func s_v2 GetMousePosition();
external_func b32 IsMouseButtonPressed(int);
external_func b32 IsMouseButtonDown(int);
external_func float floorf(float);

struct s_player
{
	s_v2 pos,
	s_v2 vel,
}

const int c_max_tiles = 64;
const int c_tile_size = 16;
s8[c_max_tiles][c_max_tiles] tiles;


func s_v2 v2(float x, float y)
{
	return {x, y};
}

func s_v2i v2i(int x, int y)
{
	return {x, y};
}

func b8 rect_collides_rect(s_v2 pos1, s_v2 size1, s_v2 pos2, s_v2 size2)
{
	return pos1.x + size1.x > pos2.x && pos1.x < pos2.x + size2.x &&
		pos1.y + size1.y > pos2.y && pos1.y < pos2.y + size2.y;
}

func int main()
{

	SetTraceLogLevel(4);
	SetConfigFlags(64);
	InitWindow(800, 600, "AZEN");


	s_player player;
	player.pos = v2(32, 32);

	while !WindowShouldClose() {
		BeginDrawing();
		ClearBackground(BLACK);

		s_v2 mouse = GetMousePosition();

		s_v2 player_size = v2(c_tile_size, c_tile_size * 2);
		s_v2 tile_size = v2(c_tile_size, c_tile_size);

		if IsMouseButtonDown(MOUSE_BUTTON_LEFT) {
			int x = mouse.x / c_tile_size;
			int y = mouse.y / c_tile_size;
			tiles[y][x] = 1;
		}

		if IsMouseButtonDown(MOUSE_BUTTON_RIGHT) {
			int x = mouse.x / c_tile_size;
			int y = mouse.y / c_tile_size;
			tiles[y][x] = 2;
		}

		for y: c_max_tiles {
			for x: c_max_tiles {
				s8 tile = tiles[y][x];
				if tile == 1 {
					DrawRectangle(x * c_tile_size, y * c_tile_size, c_tile_size, c_tile_size, RED);
				}
				if tile == 2 {
					DrawRectangle(x * c_tile_size, y * c_tile_size, c_tile_size, c_tile_size, GREEN);
				}
			}
		}

		player.vel.y += 0.01;
		player.pos.x += player.vel.x;

		s_v2i[9] offsets = {
			v2i(-1, -1), v2i(0, -1), v2i(1, 1),
			v2i(-1, 0), v2i(0, 0), v2i(1, 0),
			v2i(-1, 1), v2i(0, 1), v2i(1, 1),
		};

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		x collision start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		s_v2i player_index = v2i(floorf(player.pos.x / c_tile_size), floorf(player.pos.y / c_tile_size));
		for offsets {
			it.x += player_index.x;
			it.y += player_index.y;
			if it.x < 0 || it.x >= c_max_tiles { continue; }
			if it.y < 0 || it.y >= c_max_tiles { continue; }
			s8 tile = tiles[it.y][it.x];
			s_v2 tile_pos = v2(it.x * c_tile_size, it.y * c_tile_size);
			if tile > 0 {
				if rect_collides_rect(player.pos, player_size, tile_pos, tile_size) {
					if player.vel.x > 0 {
						player.pos.x = tile_pos.x - player_size.x;
					}
					else {
						player.pos.x = tile_pos.x + tile_size.x;
					}
					player.vel.x = 0;
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		x collision end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		player.pos.y += player.vel.y;

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		y collision start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		player_index = v2i(floorf(player.pos.x / c_tile_size), floorf(player.pos.y / c_tile_size));
		for offsets {
			it.x += player_index.x;
			it.y += player_index.y;
			if it.x < 0 || it.x >= c_max_tiles { continue; }
			if it.y < 0 || it.y >= c_max_tiles { continue; }
			s8 tile = tiles[it.y][it.x];
			s_v2 tile_pos = v2(it.x * c_tile_size, it.y * c_tile_size);
			if tile > 0 {
				if rect_collides_rect(player.pos, player_size, tile_pos, tile_size) {
					if player.vel.y > 0 {
						player.pos.y = tile_pos.y - player_size.y * 3;
					}
					else {
						player.pos.y = tile_pos.y + tile_size.y;
					}
					player.vel.y = 0;
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		y collision end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		DrawRectangle(player.pos.x, player.pos.y, player_size.x, player_size.y, BLUE);

		DrawFPS(16, 16);

		EndDrawing();
	}
}
