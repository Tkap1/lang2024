

// raylib

struct s_color
{
	u8 r,
	u8 g,
	u8 b,
	u8 a,
}
struct s_texture
{
	u32 id,
	int width,
	int height,
	int mipmaps,
	int format,
}

const int LOG_WARNING = 4;
const int FLAG_VSYNC_HINT = 64;
const s_color BLACK = {0, 0, 0, 0};
const s_color RED = {230, 41, 55, 255};
const s_color GREEN = {0, 228, 48, 255};
const s_color BLUE = {0, 121, 241, 255};
const s_color WHITE = {255, 255, 255, 255};
const s_color DARK = {50, 50, 50, 255};
const int MOUSE_BUTTON_LEFT = 0;
const int MOUSE_BUTTON_RIGHT = 1;

const int KEY_NULL = 0;
const int KEY_APOSTROPHE = 39;
const int KEY_COMMA = 44;
const int KEY_MINUS = 45;
const int KEY_PERIOD = 46;
const int KEY_SLASH = 47;
const int KEY_ZERO = 48;
const int KEY_ONE = 49;
const int KEY_TWO = 50;
const int KEY_THREE = 51;
const int KEY_FOUR = 52;
const int KEY_FIVE = 53;
const int KEY_SIX = 54;
const int KEY_SEVEN = 55;
const int KEY_EIGHT = 56;
const int KEY_NINE = 57;
const int KEY_SEMICOLON = 59;
const int KEY_EQUAL = 61;
const int KEY_A = 65;
const int KEY_B = 66;
const int KEY_C = 67;
const int KEY_D = 68;
const int KEY_E = 69;
const int KEY_F = 70;
const int KEY_G = 71;
const int KEY_H = 72;
const int KEY_I = 73;
const int KEY_J = 74;
const int KEY_K = 75;
const int KEY_L = 76;
const int KEY_M = 77;
const int KEY_N = 78;
const int KEY_O = 79;
const int KEY_P = 80;
const int KEY_Q = 81;
const int KEY_R = 82;
const int KEY_S = 83;
const int KEY_T = 84;
const int KEY_U = 85;
const int KEY_V = 86;
const int KEY_W = 87;
const int KEY_X = 88;
const int KEY_Y = 89;
const int KEY_Z = 90;
const int KEY_LEFT_BRACKET = 91;
const int KEY_BACKSLASH = 92;
const int KEY_RIGHT_BRACKET = 93;
const int KEY_GRAVE = 96;
const int KEY_SPACE = 32;
const int KEY_ESCAPE = 256;
const int KEY_ENTER = 257;
const int KEY_TAB = 258;
const int KEY_BACKSPACE = 259;
const int KEY_INSERT = 260;
const int KEY_DELETE = 261;
const int KEY_RIGHT = 262;
const int KEY_LEFT = 263;
const int KEY_DOWN = 264;
const int KEY_UP = 265;
const int KEY_PAGE_UP = 266;
const int KEY_PAGE_DOWN = 267;
const int KEY_HOME = 268;
const int KEY_END = 269;
const int KEY_CAPS_LOCK = 280;
const int KEY_SCROLL_LOCK = 281;
const int KEY_NUM_LOCK = 282;
const int KEY_PRINT_SCREEN = 283;
const int KEY_PAUSE = 284;
const int KEY_F1 = 290;
const int KEY_F2 = 291;
const int KEY_F3 = 292;
const int KEY_F4 = 293;
const int KEY_F5 = 294;
const int KEY_F6 = 295;
const int KEY_F7 = 296;
const int KEY_F8 = 297;
const int KEY_F9 = 298;
const int KEY_F10 = 299;
const int KEY_F11 = 300;
const int KEY_F12 = 301;
const int KEY_LEFT_SHIFT = 340;
const int KEY_LEFT_CONTROL = 341;
const int KEY_LEFT_ALT = 342;
const int KEY_LEFT_SUPER = 343;
const int KEY_RIGHT_SHIFT = 344;
const int KEY_RIGHT_CONTROL = 345;
const int KEY_RIGHT_ALT = 346;
const int KEY_RIGHT_SUPER = 347;
const int KEY_KB_MENU = 348;
const int KEY_KP_0 = 320;
const int KEY_KP_1 = 321;
const int KEY_KP_2 = 322;
const int KEY_KP_3 = 323;
const int KEY_KP_4 = 324;
const int KEY_KP_5 = 325;
const int KEY_KP_6 = 326;
const int KEY_KP_7 = 327;
const int KEY_KP_8 = 328;
const int KEY_KP_9 = 329;
const int KEY_KP_DECIMAL = 330;
const int KEY_KP_DIVIDE = 331;
const int KEY_KP_MULTIPLY = 332;
const int KEY_KP_SUBTRACT = 333;
const int KEY_KP_ADD = 334;
const int KEY_KP_ENTER = 335;
const int KEY_KP_EQUAL = 336;
const int KEY_BACK = 4;
const int KEY_MENU = 5;
const int KEY_VOLUME_UP = 24;
const int KEY_VOLUME_DOWN = 2;
const int TEXTURE_FILTER_ANISOTROPIC_16X = 5;

struct s_v2
{
	float x,
	float y,
}

struct s_v2i
{
	int x,
	int y,
}


external_func void SetTraceLogLevel(s32);
external_func void SetConfigFlags(u32);
external_func void InitWindow(s32, s32, char*);
external_func b32 WindowShouldClose();
external_func void BeginDrawing();
external_func void DrawRectangle(s32, s32, s32, s32, s_color);
external_func void DrawFPS(s32, s32);
external_func void EndDrawing();
external_func void ClearBackground(s_color);
external_func int rand();
external_func s_v2 GetMousePosition();
external_func b32 IsMouseButtonPressed(int);
external_func b32 IsMouseButtonDown(int);
external_func float floorf(float);
external_func b32 IsKeyDown(int);
external_func b32 IsKeyPressed(int);
external_func s_texture LoadTexture(char*);
external_func void SetTextureFilter(s_texture, int);
external_func void DrawTexture(s_texture, int, int, s_color);
external_func void DrawTextureEx(s_texture, s_v2, float, float, s_color);
external_func float sinf(float);
external_func float sqrtf(float);
external_func double GetTime();
external_func float GetFrameTime();
external_func int printf(char*);
external_func void SetTargetFPS(int);

struct s_player
{
	import s_v2 pos,
	s_v2 vel,
	int shoot_timer,
}

struct s_input_data
{
	int shoot,
	int move_left,
	int move_right,
	int move_up,
	int move_down,
	int jump,
	int place_tile,
	int remove_tile,
}

const int c_max_projectiles = 128;

struct s_projectiles
{
	b8[c_max_projectiles] active,
	s_v2[c_max_projectiles] pos,
	s_v2[c_max_projectiles] vel,
}

struct s_camera
{
	s_v2 pos,
	s_v2 offset,
}

const int c_max_tiles = 64;
// @Note(tkap, 15/02/2024): For things that get undone/redone by undo system
struct s_editor_data
{
	s8[c_max_tiles][c_max_tiles] tiles,
}

enum e_animation
{
	explosion,
}

enum e_texture
{
	player_face,
	player_body,
	player_hand,
	tile,
	explosion1,
	explosion2,
	explosion3,
	explosion4,
	explosion5,
	explosion6,
	explosion7,
	explosion8,
	explosion9,
	explosion10,
	explosion11,
	explosion12,
}

struct s_editor
{
	import s_editor_data data,
	int curr_tile,
}

struct s_animation
{
	s_v2 pos,
	int id,
	float time,
	int curr_frame,
}

struct s_animation_data
{
	float delay,
	int frame_count,
	int[32] frames,
}

s_texture[e_texture.count] g_textures;
s_animation_data[e_animation.count] g_animations;
s8[c_max_tiles][c_max_tiles] g_tiles;
s_camera camera;
float delta;
float update_timer;
const int c_updates_per_second = 240;
const float c_update_delay = 1.0 / c_updates_per_second;
const int ww = 1280;
const int wh = 900;
s_v2 tile_size;
s_v2 player_size;
float player_scale = 0.4;
float tile_scale = 0.25;
s_player player;
s_projectiles projectiles;
s_v2 projectile_size;
s_v2 mouse;
s_v2 world_mouse;
const int c_shoot_delay = 20;
const float c_max_walk_vel = 1;
int state = 1;
int next_state = 0;
s_input_data input;
s_editor editor;
int animation_count = 0;
s_animation[128] animations;

func int main()
{

	SetTraceLogLevel(LOG_WARNING);
	SetConfigFlags(FLAG_VSYNC_HINT);

	InitWindow(ww, wh, "AZEN");

	g_textures[e_texture.player_body] = load_texture("assets/pink_body_square.png");
	g_textures[e_texture.tile] = load_texture("assets/tile_grey.png");
	g_textures[e_texture.player_face] = load_texture("assets/face_h.png");
	g_textures[e_texture.player_hand] = load_texture("assets/pink_hand_open.png");
	g_textures[e_texture.explosion1] = load_texture("assets/explosion-d1.png");
	g_textures[e_texture.explosion2] = load_texture("assets/explosion-d2.png");
	g_textures[e_texture.explosion3] = load_texture("assets/explosion-d3.png");
	g_textures[e_texture.explosion4] = load_texture("assets/explosion-d4.png");
	g_textures[e_texture.explosion5] = load_texture("assets/explosion-d5.png");
	g_textures[e_texture.explosion6] = load_texture("assets/explosion-d6.png");
	g_textures[e_texture.explosion7] = load_texture("assets/explosion-d7.png");
	g_textures[e_texture.explosion8] = load_texture("assets/explosion-d8.png");
	g_textures[e_texture.explosion9] = load_texture("assets/explosion-d9.png");
	g_textures[e_texture.explosion10] = load_texture("assets/explosion-d10.png");
	g_textures[e_texture.explosion11] = load_texture("assets/explosion-d11.png");
	g_textures[e_texture.explosion12] = load_texture("assets/explosion-d12.png");

	g_animations[e_animation.explosion].delay = 0.1;
	g_animations[e_animation.explosion].frame_count = 12;
	g_animations[e_animation.explosion].frames[0] = e_texture.explosion1;
	g_animations[e_animation.explosion].frames[1] = e_texture.explosion2;
	g_animations[e_animation.explosion].frames[2] = e_texture.explosion3;
	g_animations[e_animation.explosion].frames[3] = e_texture.explosion4;
	g_animations[e_animation.explosion].frames[4] = e_texture.explosion5;
	g_animations[e_animation.explosion].frames[5] = e_texture.explosion6;
	g_animations[e_animation.explosion].frames[6] = e_texture.explosion7;
	g_animations[e_animation.explosion].frames[7] = e_texture.explosion8;
	g_animations[e_animation.explosion].frames[8] = e_texture.explosion9;
	g_animations[e_animation.explosion].frames[9] = e_texture.explosion10;
	g_animations[e_animation.explosion].frames[10] = e_texture.explosion11;
	g_animations[e_animation.explosion].frames[11] = e_texture.explosion12;

	// for e_texture.count {
	// 	printf("%i\n", g_textures[it].width);
	// }

	tile_size = v2(g_textures[e_texture.tile].width * tile_scale, g_textures[e_texture.tile].height * tile_scale);
	player_size = v2(g_textures[e_texture.player_body].width * player_scale, g_textures[e_texture.player_body].height * player_scale);

	player.pos = v2(32, 32);

	int bottom_tile = wh / tile_size.x;
	for x: c_max_tiles {
		g_tiles[bottom_tile][x] = 1;
	}

	projectile_size = v2(32, 32);

	while !WindowShouldClose() {
		delta = GetFrameTime();

		do_input();
		update_timer += delta;
		while update_timer >= c_update_delay {
			update_timer -= c_update_delay;
			update();
		}
		s8[c_max_tiles][c_max_tiles]* tiles = &g_tiles;
		if(state == 2) {
			tiles = &editor.tiles;
		}
		render(tiles);
	}
}

func void do_input()
{
	if state == 1 {
		if IsKeyPressed(KEY_F1) {
			next_state = 2;
		}

		input.shoot = IsMouseButtonDown(MOUSE_BUTTON_LEFT);
		input.move_left = IsKeyDown(KEY_LEFT) || IsKeyDown(KEY_A);
		input.move_right = IsKeyDown(KEY_RIGHT) || IsKeyDown(KEY_D);
		input.jump = IsKeyPressed(KEY_SPACE);
	}

	if state == 2 {
		if IsKeyPressed(KEY_F1) {
			next_state = 1;
		}

		input.move_left = IsKeyDown(KEY_LEFT) || IsKeyDown(KEY_A);
		input.move_right = IsKeyDown(KEY_RIGHT) || IsKeyDown(KEY_D);
		input.move_up = IsKeyDown(KEY_UP) || IsKeyDown(KEY_W);
		input.move_down = IsKeyDown(KEY_DOWN) || IsKeyDown(KEY_S);
		input.place_tile = IsMouseButtonDown(MOUSE_BUTTON_LEFT);
		input.remove_tile = IsMouseButtonDown(MOUSE_BUTTON_RIGHT);
	}
}

func void update()
{
	mouse = GetMousePosition();
	world_mouse = to_world(mouse);

	if player.shoot_timer < c_shoot_delay {
		player.shoot_timer += 1;
	}

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		change state start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if next_state != 0 {
		state = next_state;
		if next_state == 1 {
			g_tiles = editor.tiles;
		}
		if next_state == 2 {
			editor.tiles = g_tiles;
		}
		next_state = 0;
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		change state end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	if state == 1 {

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		create projectiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		if player.shoot_timer >= c_shoot_delay && input.shoot {
			player.shoot_timer -= c_shoot_delay;
			for c_max_projectiles {
				if !projectiles.active[it] {
					projectiles.active[it] = 1;
					s_v2 player_center = get_center(player.pos, player_size);
					projectiles.pos[it] = player_center;
					projectiles.pos[it].x -= projectile_size.x / 2;
					projectiles.pos[it].y -= projectile_size.y / 2;
					projectiles.vel[it] = dir_from_to(projectiles.pos[it], world_mouse);
					projectiles.vel[it].x *= 10;
					projectiles.vel[it].y *= 10;
					break;
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		create projectiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		{
			s_v2 dir;
			if input.move_left {
				dir.x -= 1;
			}
			if input.move_right {
				dir.x += 1;
			}
			if dir.x > 0 && player.vel.x < c_max_walk_vel {
				player.vel.x = min(c_max_walk_vel, player.vel.x + dir.x);
			}
			if dir.x < 0 && player.vel.x > -c_max_walk_vel {
				player.vel.x = max(-c_max_walk_vel, player.vel.x + dir.x);
			}
		}

		player.vel.y += 0.09;

		if input.jump {
			input.jump = 0;
			player.vel.y = -3;
		}

		player.x += player.vel.x;

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		x collision start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		{
			s_v2 player_center = get_center(player.pos, player_size);
			s_v2i player_index = v2i(floorf(player_center.x / tile_size.x), floorf(player_center.y / tile_size.y));
			for y: 7 {
				int yy = -3 + y;
				for x: 7 {
					int xx = -3 + x;
					s_v2i index = v2i(player_index.x + xx, player_index.y + yy);
					if index.x < 0 || index.x >= c_max_tiles { continue; }
					if index.y < 0 || index.y >= c_max_tiles { continue; }

					s8 tile = g_tiles[index.y][index.x];
					s_v2 tile_pos = v2(index.x * tile_size.x, index.y * tile_size.x);
					if tile > 0 {
						if rect_collides_rect(player.pos, player_size, tile_pos, tile_size) {
							if player.vel.x > 0 {
								player.x = tile_pos.x - player_size.x;
							}
							else {
								player.x = tile_pos.x + tile_size.x;
							}
						}
					}
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		x collision end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		player.y += player.vel.y;

		int is_grounded = 0;

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		y collision start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		{
			s_v2 player_center = get_center(player.pos, player_size);
			s_v2i player_index = v2i(floorf(player_center.x / tile_size.x), floorf(player_center.y / tile_size.y));
			for y: 7 {
				int yy = -3 + y;
				for x: 7 {
					int xx = -3 + x;
					s_v2i index = v2i(player_index.x + xx, player_index.y + yy);
					if index.x < 0 || index.x >= c_max_tiles { continue; }
					if index.y < 0 || index.y >= c_max_tiles { continue; }

					s8 tile = g_tiles[index.y][index.x];
					s_v2 tile_pos = v2(index.x * tile_size.x, index.y * tile_size.x);
					if tile > 0 {
						if rect_collides_rect(player.pos, player_size, tile_pos, tile_size) {
							if player.vel.y > 0 {
								player.y = tile_pos.y - player_size.y;
								is_grounded = 1;
							}
							else {
								player.y = tile_pos.y + tile_size.y;
							}
							player.vel.y = 0;
						}
					}
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		y collision end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		if is_grounded {
			player.vel.x *= 0.8;
		}


		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		projectiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		for c_max_projectiles {
			if !projectiles.active[it] { continue; }
			projectiles.pos[it].x += projectiles.vel[it].x;
			projectiles.pos[it].y += projectiles.vel[it].y;

			s_v2i col = get_tile_collision(projectiles.pos[it], projectile_size);
			if col.x == -1 { continue; }
			projectiles.active[it] = 0;
			s_v2 center = get_center(projectiles.pos[it], projectile_size);
			s_v2 player_center = get_center(player.pos, player_size);
			float distance = v2_distance(center, player_center);
			float strength = smoothstep(128, 16, distance) * 5;
			s_v2 dir = dir_from_to(center, player_center);
			s_v2 push = v2_scale(dir, strength);
			player.vel.x += push.x;
			player.vel.y += push.y;
			s_animation anim;
			anim.id = e_animation.explosion;
			anim.pos = projectiles.pos[it];
			animations[animation_count] = anim;
			animation_count += 1;
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		projectiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


		camera.offset.x = ww / 2 - player_size.x / 2;
		camera.offset.y = wh / 2 - player_size.y / 2;
		camera.pos.x = player.x;
		camera.pos.y = player.y;


	}

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		editor start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	if state == 2 {

		s_v2i index = pos_to_tile_index(world_mouse);
		if input.place_tile {
			if is_valid_tile_index(index) {
				editor.tiles[index.y][index.x] = 1;
			}
		}
		if input.remove_tile {
			if is_valid_tile_index(index) {
				editor.tiles[index.y][index.x] = 0;
			}
		}

		camera.offset.x = ww / 2 - player_size.x / 2;
		camera.offset.y = wh / 2 - player_size.y / 2;
		const float cam_speed = 3;
		if input.move_left {
			camera.pos.x -= cam_speed;
		}
		if input.move_right {
			camera.pos.x += cam_speed;
		}
		if input.move_up {
			camera.pos.y -= cam_speed;
		}
		if input.move_down {
			camera.pos.y += cam_speed;
		}
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		editor end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

}

func void render(s8[c_max_tiles][c_max_tiles]* tiles)
{
	BeginDrawing();
	ClearBackground(BLACK);

	float time = GetTime();

	mouse = GetMousePosition();
	world_mouse = to_world(mouse);

	{
		int right = (ww + camera.pos.x) / tile_size.x + 1;
		int down = (wh + camera.pos.y) / tile_size.y + 1;
		for y: down {
			if y >= c_max_tiles { continue; }
			for x: right {
				if x >= c_max_tiles { continue; }
				s8 tile = tiles[y][x];
				s_v2 tile_pos = v2(x * tile_size.x, y * tile_size.x);
				if tile == 0 {
					s_color color = DARK;
					if x % 2 == 0 {
						color = {100, 25, 25, 255};
					}
					DrawTextureEx(g_textures[e_texture.tile], to_screen(tile_pos), 0, tile_scale, color);
				}
				if tile == 1 {
					// DrawRectangle(x * tile_size.x, y * tile_size.x, tile_size.x, tile_size.x, RED);
					DrawTextureEx(g_textures[e_texture.tile], to_screen(tile_pos), 0, tile_scale, WHITE);
				}
				if tile == 2 {
					DrawTextureEx(g_textures[e_texture.tile], to_screen(tile_pos), 0, tile_scale, WHITE);
				}
			}
		}
	}

	for animation_count {
		s_animation* anim = &animations[it];
		s_animation_data data = g_animations[anim.id];
		DrawTextureEx(g_textures[data.frames[anim.curr_frame]], to_screen(anim.pos), 0, player_scale * 2, WHITE);
		anim.time += delta;
		if anim.time > data.delay {
			anim.time -= data.delay;
			anim.curr_frame = (anim.curr_frame + 1) % data.frame_count;
			if anim.curr_frame == 0 {
				animation_count -= 1;
				animations[it] = animations[animation_count];
				continue;
			}
		}
	}


	{
		DrawTextureEx(g_textures[e_texture.player_body], to_screen(player.pos), 0, player_scale, WHITE);
	}

	{
		s_v2 face_pos = player.pos;
		face_pos.x += player_size.x / 4;
		face_pos.y += player_size.y / 4;
		DrawTextureEx(g_textures[e_texture.player_face], to_screen(face_pos), 0, player_scale, WHITE);
	}

	{
		s_v2 hand_pos = player.pos;
		hand_pos.x -= 80 * player_scale;
		hand_pos.y += 20;
		hand_pos.y += sinf(time * 6) * 5;
		DrawTextureEx(g_textures[e_texture.player_hand], to_screen(hand_pos), 0, player_scale, WHITE);
	}

	{
		s_v2 hand_pos = player.pos;
		hand_pos.x += 200 * player_scale;
		hand_pos.y += 20;
		hand_pos.y += sinf(time * 6) * 5;
		DrawTextureEx(g_textures[e_texture.player_hand], to_screen(hand_pos), 0, player_scale, WHITE);
	}

	// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		projectiles start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
	for c_max_projectiles {
		if !projectiles.active[it] { continue; }
		s_v2 pos = to_screen(projectiles.pos[it]);
		DrawRectangle(pos.x, pos.y, projectile_size.x, projectile_size.y, RED);
	}
	// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		projectiles end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	DrawFPS(16, 16);

	EndDrawing();
}

func s_v2i get_tile_collision(s_v2 pos, s_v2 size)
{
	s_v2 center = get_center(pos, size);
	s_v2i base_index = v2i(floorf(center.x / tile_size.x), floorf(center.y / tile_size.y));
	for y: 7 {
		int yy = -3 + y;
		for x: 7 {
			int xx = -3 + x;
			s_v2i index = v2i(base_index.x + xx, base_index.y + yy);
			if index.x < 0 || index.x >= c_max_tiles { continue; }
			if index.y < 0 || index.y >= c_max_tiles { continue; }

			s8 tile = g_tiles[index.y][index.x];
			s_v2 tile_pos = v2(index.x * tile_size.x, index.y * tile_size.x);
			if tile > 0 {
				if rect_collides_rect(pos, size, tile_pos, tile_size) {
					return index;
				}
			}
		}
	}
	return v2i(-1, -1);
}

func float smoothstep(float edge0, float edge1, float val)
{
	float t = clamp((val - edge0) / (edge1 - edge0), 0.0, 1.0);
	return t * t * (3.0 - 2.0 * t);
}

func s_v2 v2_scale(s_v2 v, float scalar)
{
	v.x *= scalar;
	v.y *= scalar;
	return v;
}

func float v2_distance(s_v2 a, s_v2 b)
{
	a.x -= b.x;
	a.y -= b.y;
	return v2_length(a);
}

func float clamp(float val, float min_val, float max_val)
{
	return max(min(val, max_val), min_val);
}

func float min(float a, float b)
{
	if a >= b { return b; }
	return a;
}

func float max(float a, float b)
{
	if a <= b { return b; }
	return a;
}

func s_v2 to_screen(s_v2 v)
{
	s_v2 result = v;
	result.x -= camera.pos.x;
	result.y -= camera.pos.y;
	result.x += camera.offset.x;
	result.y += camera.offset.y;
	return result;
}

func s_v2 to_world(s_v2 v)
{
	s_v2 result = v;
	result.x -= camera.offset.x;
	result.y -= camera.offset.y;
	result.x += camera.pos.x;
	result.y += camera.pos.y;
	return result;
}

func s_v2 v2(float x, float y)
{
	return {x, y};
}

func s_v2i v2i(int x, int y)
{
	return {x, y};
}

func b8 rect_collides_rect(s_v2 pos1, s_v2 size1, s_v2 pos2, s_v2 size2)
{
	return pos1.x + size1.x > pos2.x && pos1.x < pos2.x + size2.x &&
		pos1.y + size1.y > pos2.y && pos1.y < pos2.y + size2.y;
}

func s_v2 get_center(s_v2 pos, s_v2 size)
{
	s_v2 result = pos;
	result.x += size.x / 2;
	result.y += size.y / 2;
	return result;
}

func float v2_length(s_v2 v)
{
	return sqrtf(v.x * v.x + v.y * v.y);
}

func s_v2 v2_normalized(s_v2 v)
{
	float length = v2_length(v);
	if(length > 0) {
		v.x /= length;
		v.y /= length;
	}
	return v;
}

func s_v2 dir_from_to(s_v2 from, s_v2 to)
{
	s_v2 result = to;
	result.x -= from.x;
	result.y -= from.y;
	return v2_normalized(result);
}

func s_v2i pos_to_tile_index(s_v2 pos)
{
	return v2i(pos.x / tile_size.x, pos.y / tile_size.y);
}

func int is_valid_tile_index(s_v2i index) {
	if index.x < 0 || index.x >= c_max_tiles { return 0; }
	if index.y < 0 || index.y >= c_max_tiles { return 0; }
	return 1;
}

func s_texture load_texture(char* path)
{
	s_texture texture = LoadTexture(path);
	SetTextureFilter(texture, TEXTURE_FILTER_ANISOTROPIC_16X);
	return texture;
}