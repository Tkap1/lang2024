

// raylib

struct s_color
{
	u8 r,
	u8 g,
	u8 b,
	u8 a,
}
const int LOG_WARNING = 4;
const int FLAG_VSYNC_HINT = 64;
const s_color BLACK = {0, 0, 0, 0};
const s_color RED = {230, 41, 55, 255};
const s_color GREEN = {0, 228, 48, 255};
const s_color BLUE = {0, 121, 241, 255};
const int MOUSE_BUTTON_LEFT = 0;
const int MOUSE_BUTTON_RIGHT = 1;

const int KEY_RIGHT = 262;
const int KEY_LEFT = 263;
const int KEY_DOWN = 264;
const int KEY_UP = 265;
const int KEY_SPACE = 32;

struct s_v2
{
	float x,
	float y,
}


struct s_v2i
{
	int x,
	int y,
}


external_func void SetTraceLogLevel(s32);
external_func void SetConfigFlags(u32);
external_func void InitWindow(s32, s32, char*);
external_func b32 WindowShouldClose();
external_func void BeginDrawing();
external_func void DrawRectangle(s32, s32, s32, s32, s_color);
external_func void DrawFPS(s32, s32);
external_func void EndDrawing();
external_func void ClearBackground(s_color);
external_func int rand();
external_func s_v2 GetMousePosition();
external_func b32 IsMouseButtonPressed(int);
external_func b32 IsMouseButtonDown(int);
external_func float floorf(float);
external_func b32 IsKeyDown(int);
external_func b32 IsKeyPressed(int);

struct s_player
{
	s_v2 pos,
	s_v2 vel,
}

const int c_max_tiles = 64;
const int c_tile_size = 16;
s8[c_max_tiles][c_max_tiles] tiles;


func s_v2 v2(float x, float y)
{
	return {x, y};
}

func s_v2i v2i(int x, int y)
{
	return {x, y};
}

func b8 rect_collides_rect(s_v2 pos1, s_v2 size1, s_v2 pos2, s_v2 size2)
{
	return pos1.x + size1.x > pos2.x && pos1.x < pos2.x + size2.x &&
		pos1.y + size1.y > pos2.y && pos1.y < pos2.y + size2.y;
}

func int main()
{

	SetTraceLogLevel(4);
	SetConfigFlags(64);
	InitWindow(800, 600, "AZEN");


	s_player player;
	player.pos = v2(32, 32);

	while !WindowShouldClose() {
		BeginDrawing();
		ClearBackground(BLACK);

		s_v2 mouse = GetMousePosition();

		s_v2 player_size = v2(c_tile_size, c_tile_size * 2);
		s_v2 tile_size = v2(c_tile_size, c_tile_size);

		if IsMouseButtonDown(MOUSE_BUTTON_LEFT) {
			int x = mouse.x / c_tile_size;
			int y = mouse.y / c_tile_size;
			tiles[y][x] = 1;
		}

		if IsMouseButtonDown(MOUSE_BUTTON_RIGHT) {
			int x = mouse.x / c_tile_size;
			int y = mouse.y / c_tile_size;
			tiles[y][x] = 2;
		}

		s_v2 dir;
		if IsKeyDown(KEY_LEFT) {
			dir.x -= 1;
		}
		if IsKeyDown(KEY_RIGHT) {
			dir.x += 1;
		}
		player.vel.x += dir.x * 2;

		player.vel.y += 0.09;
		if IsKeyPressed(KEY_SPACE) {
			player.vel.y = -3;
		}

		for y: c_max_tiles {
			for x: c_max_tiles {
				s8 tile = tiles[y][x];
				if tile == 1 {
					DrawRectangle(x * c_tile_size, y * c_tile_size, c_tile_size, c_tile_size, RED);
				}
				if tile == 2 {
					DrawRectangle(x * c_tile_size, y * c_tile_size, c_tile_size, c_tile_size, GREEN);
				}
			}
		}

		player.pos.x += player.vel.x;

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		x collision start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		s_v2i player_index = v2i(floorf(player.pos.x / c_tile_size), floorf(player.pos.y / c_tile_size));
		for y: 5 {
			int yy = -2 + y;
			for x: 5 {
				int xx = -2 + x;
				s_v2i index = v2i(player_index.x + xx, player_index.y + yy);
				if index.x < 0 || index.x >= c_max_tiles { continue; }
				if index.y < 0 || index.y >= c_max_tiles { continue; }

				s8 tile = tiles[index.y][index.x];
				s_v2 tile_pos = v2(index.x * c_tile_size, index.y * c_tile_size);
				if tile > 0 {
					if rect_collides_rect(player.pos, player_size, tile_pos, tile_size) {
						if player.vel.x > 0 {
							player.pos.x = tile_pos.x - player_size.x;
						}
						else {
							player.pos.x = tile_pos.x + tile_size.x;
						}
					}
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		x collision end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		player.vel.x = 0;
		player.pos.y += player.vel.y;

		// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv		y collision start		vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		player_index = v2i(floorf(player.pos.x / c_tile_size), floorf(player.pos.y / c_tile_size));
		for y: 5 {
			int yy = -2 + y;
			for x: 5 {
				int xx = -2 + x;
				s_v2i index = v2i(player_index.x + xx, player_index.y + yy);
				if index.x < 0 || index.x >= c_max_tiles { continue; }
				if index.y < 0 || index.y >= c_max_tiles { continue; }

				s8 tile = tiles[index.y][index.x];
				s_v2 tile_pos = v2(index.x * c_tile_size, index.y * c_tile_size);
				if tile > 0 {
					if rect_collides_rect(player.pos, player_size, tile_pos, tile_size) {
						if player.vel.y > 0 {
							player.pos.y = tile_pos.y - player_size.y;
						}
						else {
							player.pos.y = tile_pos.y + tile_size.y;
						}
						player.vel.y = 0;
					}
				}
			}
		}
		// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		y collision end		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		DrawRectangle(player.pos.x, player.pos.y, player_size.x, player_size.y, BLUE);

		DrawFPS(16, 16);

		EndDrawing();
	}
}
